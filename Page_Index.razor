@page "/"

<div class="bar">
    <div class="@Info_GetStyleClass()">
        <Component_Button Icon="edit" OnClick="Edit_OnClick" Enabled="@(ready && !disposing)"
                          Style="position: absolute; align-self: flex-end; margin: 2.5em -.5em 0 0; " />
        <Component_Button Icon="close" OnClick="ToggleInfo" Enabled="@(ready && !disposing)"
                          Style="position: absolute; align-self: flex-end; margin: -.5em -.5em 0 0; " />
        <div class="qr" style="background-image: url(@Selection.ActiveDataItem?.qr); "></div>
    </div>
    <div class="content">
        <Component_Timer @ref="timerComponent" Value="@Selection.ActiveDataItemTimer" />
        <Component_Otp Current="@Selection.ActiveDataItemCurrentOtp"
                       Next="@Selection.ActiveDataItemNextOtp" />
        @if (Selection.ActiveDataItem is not null && !visible)
        {
            <Component_Button Icon="info" OnClick="ToggleInfo"
                              Style="position: absolute; right: 3.25em; " />
        }
        <Component_Button Icon="tools" OnClick="Tools_OnClick" Enabled="@(ready && !disposing)" />
    </div>
</div>
<div class="items">
    @foreach (var item in EnumerateItems())
    {
        <div class="@Item_GetStyleClass(item)"
             style="@Item_GetAdditionalStyle(item)"
             @onclick="() => Item_OnClick(item)">
            <div class="service" data-type="@item.service"></div>
            <div class="name">@item.name</div>
        </div>
    }
</div>

@inject NavigationManager nav

@code {

    Component_Timer timerComponent;

    bool visible;

    Task intervalTask;
    bool forceRender;

    bool ready;
    bool disposing;
    bool disposed;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        await base.OnAfterRenderAsync(firstRender);

        if (!firstRender)
            return;

        Selection.data = await Data.LoadAsync();
        if (Selection.ActiveDataItem is null)
            Selection.activeSecret = EnumerateItems().FirstOrDefault()?.secret;

        intervalTask = Task.Run(async () =>
        {
            while (!disposing)
            {
                Selection.ComputeActiveDataItem();
                await InvokeAsync(StateHasChanged);
                await timerComponent.RenderAsync();
                if (!ready)
                {
                    ready = true;
                    await InvokeAsync(StateHasChanged);
                }
                for (var i = 0; i < 20 && !disposed && !forceRender; i++)
                    await Task.Delay(50);
                forceRender = false;
            }

            Selection.ClearActiveDataItem();
            disposed = true;
        });
    }

    IEnumerable<Data.Item> EnumerateItems()
    {
        if (Selection.data is null)
            yield break;

        var items = Selection.data.items
            .Where(x => !x.hidden)
            .OrderBy(x => x.service)
            .ThenBy(x => x.name);

        foreach (var item in items)
            yield return item;
    }

    string Info_GetStyleClass()
    {
        return "info" + (visible ? " visible" : "");
    }

    void ToggleInfo()
    {
        visible = !visible;
    }

    string Item_GetStyleClass(Data.Item item)
    {
        return $"item" + (item == Selection.ActiveDataItem ? " active" : "");
    }

    string Item_GetAdditionalStyle(Data.Item item)
    {
        var color = Selection.data.colors.FirstOrDefault(x => x.name == item.service);
        if (color is null)
            return string.Empty;

        if (Selection.data.useGradients)
        {
            var gradient = string.Join(", ", [
                "transparent 0%",
                $"{color.value} 20%",
                "transparent 100%",
            ]);
            return $"background-image: linear-gradient(90deg, {gradient}); ";
        }

        return $"background-color: {color.value}; ";
    }

    void Item_OnClick(Data.Item item)
    {
        Selection.activeSecret = item.secret;
        forceRender = true;
    }

    async Task Edit_OnClick()
    {
        disposing = true;
        while (!disposed)
            await Task.Delay(50);
        nav.NavigateTo("/edit");

    }

    async Task Tools_OnClick()
    {
        disposing = true;
        while (!disposed)
            await Task.Delay(50);
        nav.NavigateTo("/tools");
    }

}
