@page "/"

<div class="bar">
    <div class="@Info_GetStyleClass()">
        <div class="button edit" @onclick="Edit_OnClick"></div>
        <div class="button close" @onclick="() => visible = false"></div>
        <div class="qr" style="@(visible ? Selection.ActiveDataItem?.GenerateQrStyle() : "")"></div>
        <div class="secret">@Selection.ActiveDataItem?.secret</div>
    </div>
    <div class="content">
        <div class="timer">
            <canvas @ref="timerCanvas" width="42" height="42"></canvas>
            <span>@Selection.ActiveDataItemTimer</span>
        </div>
        <div class="otp" @onclick="Otp_OnClick">
            @Selection.ActiveDataItemOtp
        </div>
        @if (Selection.ActiveDataItem is not null && !visible)
        {
            <div class="button info" @onclick="() => visible = true"></div>
        }
        <div class="button tools" @onclick="Tools_OnClick"></div>
    </div>
</div>
<div class="items">
    @foreach (var item in EnumerateItems())
    {
        <div class="@Item_GetStyleClass(item)"
             style="@item.GetStyle(Selection.data.colors)"
             @onclick="() => Item_OnClick(item)">
            <div class="service" data-type="@item.service"></div>
            <div class="name">@item.name</div>
        </div>
    }
</div>

@implements IDisposable

@inject IJSRuntime js
@inject NavigationManager nav

@using Microsoft.Maui.ApplicationModel.DataTransfer

@code {

    ElementReference timerCanvas;

    bool visible;

    Task intervalTask;
    bool disposed;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        await base.OnAfterRenderAsync(firstRender);

        if (!firstRender)
            return;

        Selection.data = await Data.LoadAsync();

        intervalTask = Task.Run(async () =>
        {
            while (!disposed)
            {
                Selection.ComputeActiveDataItem();

                await js.InvokeVoidAsync(
                    "renderCircle",
                    new object[] {
                        timerCanvas,
                        Selection.ActiveDataItemTimer / 30f,
                        5
                    }
                );

                await InvokeAsync(StateHasChanged);
                await Task.Delay(1000);
            }
        });
    }

    public void Dispose()
    {
        disposed = true;
    }

    IEnumerable<Data.Item> EnumerateItems()
    {
        if (Selection.data is null)
            yield break;

        var items = Selection.data.items
            .Where(x => !x.hidden)
            .OrderBy(x => x.service)
            .ThenBy(x => x.name);

        foreach (var item in items)
            yield return item;
    }

    string Info_GetStyleClass()
    {
        return "info" + (visible ? " visible" : "");
    }

    string Item_GetStyleClass(Data.Item item)
    {
        return $"item" + (item == Selection.ActiveDataItem ? " active" : "");
    }

    void Item_OnClick(Data.Item item)
    {
        Selection.activeSecret = item.secret;
        Selection.ComputeActiveDataItem();
    }

    void Edit_OnClick()
    {
        nav.NavigateTo("/edit");
    }

    void Tools_OnClick()
    {
        nav.NavigateTo("/tools");
    }

    async Task Otp_OnClick()
    {
        if (Selection.ActiveDataItem is not null)
            await Clipboard.Default.SetTextAsync(Selection.ActiveDataItemOtp);
    }

}
